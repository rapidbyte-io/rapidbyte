# Destination World-Class Ingestion Design

Date: 2026-02-26
Status: Approved for execution

## Goal

Deliver world-class destination ingestion throughput and parallel scale while preserving correctness under concurrency.

Acceptance model:

- Dual gate: no phase is accepted unless both performance and correctness improve.
- Throughput targets vs current baseline runs: `+20%` on `medium`, `+10%` on `large`.
- Correctness targets: zero destination race retries, stable row counts across repeated runs, no metric integrity regressions.
- Architecture policy: all-in on new architecture, no legacy fallback path, no dormant compatibility code.

## Architecture

Use a leader-prepared, worker-write-only destination design.

- `prepare_stream_once(...)` (leader-only): executes one-time mutable setup.
- `write_stream_worker(...)` (worker-only): executes pure data writes from immutable contract.
- `WriteContract`: immutable snapshot generated by leader and consumed by workers.

Leader responsibilities:

- Schema/table ensure and drift policy application.
- Replace-mode staging preparation and ownership.
- Watermark metadata table ensure and resume metadata lookup.
- Final immutable write contract construction (table names, columns, write mode semantics, flush/checkpoint policy, resume behavior).

Worker responsibilities:

- Decode/write batches only.
- Apply contract-defined write behavior.
- Emit shard-level stats and checkpoints.
- Never perform DDL/table metadata ensure paths.

Orchestrator responsibilities:

- Ensure leader setup completes before worker fan-out.
- Start no workers if leader setup fails.
- Coordinate deterministic failure propagation and single-owner finalization.

Explicit non-goals in this phase:

- No CDC or incremental partition behavior changes.
- No compatibility fallback path for legacy destination writer orchestration.

## Correctness Model

### Invariants

1. Single setup writer per logical stream.
2. Immutable worker contract after leader prepare.
3. Replace-mode setup/finalization owned by a single authority.
4. Worker path cannot perform DDL or metadata setup.
5. Fail-fast startup: setup failure aborts before data workers begin.

### Failure handling

- Leader setup failure: stream fails before worker launch.
- Worker failure: cancel sibling workers for that stream and fail deterministically.
- Finalization failure: fail run with commit-state-aware classification.

### Correctness success criteria

- Repeated parallel runs produce zero destination DDL conflict retries.
- Row counts are stable across repeated same-input runs.
- Aggregated metrics remain internally consistent (stream totals and wait/process fields).

## CPU Utilization and Throughput Model

Parallelism is necessary but not sufficient. The design must prove effective core utilization when workload permits.

Required observability:

- Rapidbyte process CPU utilization over run windows.
- Destination worker active-write time vs wait time.
- Per-worker throughput and skew.
- Channel pressure/backpressure indicators.

Utilization acceptance target:

- For CPU-capable `medium`/`large` runs, sustain strong worker engagement during destination write windows while meeting throughput and correctness gates.

## Phased Delivery

### Phase 0: Instrumentation Baseline Lock

- Add run-level rapidbyte process CPU utilization capture to benchmark outputs.
- Add worker-level destination timing and throughput metrics.
- Add shard skew metrics.

Exit gate:

- Metrics appear in benchmark JSON without changing behavior.

### Phase 1: Leader Prepare + Worker Write-Only Split

- Introduce `prepare_stream_once` and `WriteContract`.
- Refactor worker write path to be contract-only.
- Remove worker access to setup paths.

Exit gate:

- Repeated `e2e_parallel` runs: zero destination race retries, stable counts.
- Replace/permissions regression remains fixed.

### Phase 2: Orchestrator Hardening for Parallel Destination

- Enforce startup sequencing: setup complete before fan-out.
- Enforce deterministic worker cancellation on first stream failure.
- Enforce single-owner finalize lifecycle.

Exit gate:

- Deterministic behavior under repeated stress and fault cases.

### Phase 3: Throughput and Utilization Optimization

- Tune destination defaults for parallel path while preserving explicit overrides.
- Reduce worker skew and wait-heavy imbalance.
- Eliminate serialization hotspots visible in metrics.

Exit gate (dual gate):

- Throughput: `>= +20% medium`, `>= +10% large`.
- Correctness: zero race retries, stable counts, metric consistency maintained.

### Phase 4: Hard Cutover and Debt Prevention

- Remove legacy destination orchestration code paths.
- Keep only new architecture path.
- Align tests/docs/harness with new model only.

Exit gate:

- No dormant fallback path remains.
- Full validation suite and benchmark gates pass on new architecture only.

## Validation Matrix

1. Unit/contract tests:
   - Write contract completeness and immutability.
   - Worker path cannot execute setup operations.
   - Replace-mode single-owner finalize behavior.
2. Integration tests:
   - Pipeline integration suite.
   - Repeated parallel scenario runs.
   - Replace+permissions regression scenario repeats.
3. Benchmark tests:
   - `medium` and `large` profile matrices with current harness.
   - Throughput and correctness dual-gate checks.
   - CPU utilization and worker engagement checks.
4. Quality checks:
   - `cargo fmt`, `cargo clippy`, `cargo test --workspace`.
   - Connector checks required by current workflow.

## Stop/No-Go Conditions

- Any destination race retry appears in repeated parallel runs.
- Any repeated-run row-count variance appears for same inputs.
- Throughput misses floor on either profile target.
- Utilization gains appear but correctness regresses, or vice versa.

## Implementation Principles

- Structural fixes over tuning-only fixes.
- Correctness invariants enforced by code boundaries, not convention.
- No tech debt carry-forward from legacy destination orchestration.
- Keep observability first-class so regressions are immediately visible.
