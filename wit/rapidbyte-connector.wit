package rapidbyte:connector@2.0.0;

interface types {
    enum validation-status {
        success,
        failed,
        warning,
    }

    enum error-category {
        config,
        auth,
        permission,
        rate-limit,
        transient-network,
        transient-db,
        data,
        schema,
        internal,
    }

    enum error-scope {
        per-stream,
        per-batch,
        per-record,
    }

    enum backoff-class {
        fast,
        normal,
        slow,
    }

    enum commit-state {
        before-commit,
        after-commit-unknown,
        after-commit-confirmed,
    }

    record connector-error {
        category: error-category,
        scope: error-scope,
        code: string,
        message: string,
        retryable: bool,
        retry-after-ms: option<u64>,
        backoff-class: backoff-class,
        safe-to-retry: bool,
        commit-state: option<commit-state>,
        details-json: option<string>,
    }

    record stream-limits {
        max-batch-bytes: u64,
        max-record-bytes: u64,
        max-inflight-batches: u32,
        max-parallel-requests: u32,
        checkpoint-interval-bytes: u64,
        checkpoint-interval-rows: u64,
        checkpoint-interval-seconds: u64,
    }

    record read-summary {
        records-read: u64,
        bytes-read: u64,
        batches-emitted: u64,
        checkpoint-count: u64,
        records-skipped: u64,
    }

    record write-summary {
        records-written: u64,
        bytes-written: u64,
        batches-written: u64,
        checkpoint-count: u64,
        records-failed: u64,
    }

    record transform-summary {
        records-in: u64,
        records-out: u64,
        bytes-in: u64,
        bytes-out: u64,
        batches-processed: u64,
    }

    record validation-result {
        status: validation-status,
        message: string,
    }

    variant socket-read-result {
        data(list<u8>),
        eof,
        would-block,
    }

    variant socket-write-result {
        written(u64),
        would-block,
    }
}

interface host {
    use types.{
        connector-error,
        socket-read-result,
        socket-write-result,
    };

    emit-batch: func(batch: list<u8>) -> result<_, connector-error>;
    next-batch: func() -> result<option<list<u8>>, connector-error>;
    log: func(level: u32, msg: string);
    checkpoint: func(kind: u32, payload-json: string) -> result<_, connector-error>;
    metric: func(payload-json: string) -> result<_, connector-error>;
    emit-dlq-record: func(stream-name: string, record-json: string, error-message: string, error-category: string) -> result<_, connector-error>;
    state-get: func(scope: u32, key: string) -> result<option<string>, connector-error>;
    state-put: func(scope: u32, key: string, val: string) -> result<_, connector-error>;
    state-cas: func(scope: u32, key: string, expected: option<string>, new-val: string) -> result<bool, connector-error>;

    connect-tcp: func(host: string, port: u16) -> result<u64, connector-error>;
    socket-read: func(handle: u64, len: u64) -> result<socket-read-result, connector-error>;
    socket-write: func(handle: u64, data: list<u8>) -> result<socket-write-result, connector-error>;
    socket-close: func(handle: u64);
}

interface source-connector {
    use types.{read-summary, validation-result, connector-error};

    open: func(config-json: string) -> result<_, connector-error>;
    discover: func() -> result<string, connector-error>;
    validate: func() -> result<validation-result, connector-error>;
    run-read: func(ctx-json: string) -> result<read-summary, connector-error>;
    close: func() -> result<_, connector-error>;
}

interface dest-connector {
    use types.{write-summary, validation-result, connector-error};

    open: func(config-json: string) -> result<_, connector-error>;
    validate: func() -> result<validation-result, connector-error>;
    run-write: func(ctx-json: string) -> result<write-summary, connector-error>;
    close: func() -> result<_, connector-error>;
}

interface transform-connector {
    use types.{transform-summary, validation-result, connector-error};

    open: func(config-json: string) -> result<_, connector-error>;
    validate: func() -> result<validation-result, connector-error>;
    run-transform: func(ctx-json: string) -> result<transform-summary, connector-error>;
    close: func() -> result<_, connector-error>;
}

world rapidbyte-host {
    import host;
}

world rapidbyte-source {
    import host;
    export source-connector;
}

world rapidbyte-destination {
    import host;
    export dest-connector;
}

world rapidbyte-transform {
    import host;
    export transform-connector;
}
