package rapidbyte:connector@4.0.0;

interface types {
    type session = u64;

    enum connector-role {
        source,
        destination,
        transform,
    }

    enum run-phase {
        read,
        write,
        transform,
    }

    enum validation-status {
        success,
        failed,
        warning,
    }

    enum error-category {
        config,
        auth,
        permission,
        rate-limit,
        transient-network,
        transient-db,
        data,
        schema,
        internal,
        frame,
    }

    enum error-scope {
        per-stream,
        per-batch,
        per-record,
    }

    enum backoff-class {
        fast,
        normal,
        slow,
    }

    enum commit-state {
        before-commit,
        after-commit-unknown,
        after-commit-confirmed,
    }

    enum state-scope {
        pipeline,
        per-stream,
        connector-instance,
    }

    enum checkpoint-kind {
        source,
        destination,
        transform,
    }

    record connector-error {
        category: error-category,
        scope: error-scope,
        code: string,
        message: string,
        retryable: bool,
        retry-after-ms: option<u64>,
        backoff-class: backoff-class,
        safe-to-retry: bool,
        commit-state: option<commit-state>,
        details-json: option<string>,
    }

    record stream-limits {
        max-batch-bytes: u64,
        max-record-bytes: u64,
        max-inflight-batches: u32,
        max-parallel-requests: u32,
        checkpoint-interval-bytes: u64,
        checkpoint-interval-rows: u64,
        checkpoint-interval-seconds: u64,
    }

    record read-summary {
        records-read: u64,
        bytes-read: u64,
        batches-emitted: u64,
        checkpoint-count: u64,
        records-skipped: u64,
    }

    record write-summary {
        records-written: u64,
        bytes-written: u64,
        batches-written: u64,
        checkpoint-count: u64,
        records-failed: u64,
    }

    record transform-summary {
        records-in: u64,
        records-out: u64,
        bytes-in: u64,
        bytes-out: u64,
        batches-processed: u64,
    }

    record validation-report {
        status: validation-status,
        message: string,
        warnings: list<string>,
    }

    record run-request {
        phase: run-phase,
        stream-context-json: string,
        dry-run: bool,
        max-records: option<u64>,
    }

    record run-summary {
        role: connector-role,
        read: option<read-summary>,
        write: option<write-summary>,
        transform: option<transform-summary>,
    }

    variant socket-read-result {
        data(list<u8>),
        eof,
        would-block,
    }

    variant socket-write-result {
        written(u64),
        would-block,
    }
}

interface host {
    use types.{
        connector-error,
        socket-read-result,
        socket-write-result,
    };

    emit-batch: func(handle: u64) -> result<_, connector-error>;
    next-batch: func() -> result<option<u64>, connector-error>;
    log: func(level: u32, msg: string);
    checkpoint: func(kind: u32, payload-json: string) -> result<_, connector-error>;
    metric: func(payload-json: string) -> result<_, connector-error>;
    emit-dlq-record: func(stream-name: string, record-json: string, error-message: string, error-category: string) -> result<_, connector-error>;
    state-get: func(scope: u32, key: string) -> result<option<string>, connector-error>;
    state-put: func(scope: u32, key: string, val: string) -> result<_, connector-error>;
    state-cas: func(scope: u32, key: string, expected: option<string>, new-val: string) -> result<bool, connector-error>;

    frame-new: func(capacity: u64) -> result<u64, connector-error>;
    frame-write: func(handle: u64, chunk: list<u8>) -> result<u64, connector-error>;
    frame-seal: func(handle: u64) -> result<_, connector-error>;
    frame-len: func(handle: u64) -> result<u64, connector-error>;
    frame-read: func(handle: u64, offset: u64, len: u64) -> result<list<u8>, connector-error>;
    frame-drop: func(handle: u64);

    connect-tcp: func(host: string, port: u16) -> result<u64, connector-error>;
    socket-read: func(handle: u64, len: u64) -> result<socket-read-result, connector-error>;
    socket-write: func(handle: u64, data: list<u8>) -> result<socket-write-result, connector-error>;
    socket-close: func(handle: u64);
}

interface source {
    use types.{
        connector-error,
        run-request,
        run-summary,
        session,
        validation-report,
    };

    open: func(config-json: string) -> result<session, connector-error>;
    discover: func(session: session) -> result<string, connector-error>;
    validate: func(session: session) -> result<validation-report, connector-error>;
    run: func(session: session, request: run-request) -> result<run-summary, connector-error>;
    close: func(session: session) -> result<_, connector-error>;
}

interface destination {
    use types.{
        connector-error,
        run-request,
        run-summary,
        session,
        validation-report,
    };

    open: func(config-json: string) -> result<session, connector-error>;
    validate: func(session: session) -> result<validation-report, connector-error>;
    run: func(session: session, request: run-request) -> result<run-summary, connector-error>;
    close: func(session: session) -> result<_, connector-error>;
}

interface transform {
    use types.{
        connector-error,
        run-request,
        run-summary,
        session,
        validation-report,
    };

    open: func(config-json: string) -> result<session, connector-error>;
    validate: func(session: session) -> result<validation-report, connector-error>;
    run: func(session: session, request: run-request) -> result<run-summary, connector-error>;
    close: func(session: session) -> result<_, connector-error>;
}

world rapidbyte-host {
    import host;
}

world rapidbyte-source {
    import host;
    export source;
}

world rapidbyte-destination {
    import host;
    export destination;
}

world rapidbyte-transform {
    import host;
    export transform;
}
