//! Connector reference parsing, path resolution, and manifest loading.

use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use rapidbyte_types::manifest::ConnectorManifest;
use wasmparser::{Parser, Payload};

const MANIFEST_SECTION_NAME: &str = "rapidbyte_manifest_v1";
const CONFIG_SCHEMA_SECTION_NAME: &str = "rapidbyte_config_schema_v1";

/// Extract a ConnectorManifest from a wasm binary's custom sections.
///
/// Reads both `rapidbyte_manifest_v1` (the manifest) and optionally
/// `rapidbyte_config_schema_v1` (a separate JSON Schema section generated by
/// the derive macro).  When the config-schema section is present it takes
/// precedence over any `config_schema` already embedded in the manifest JSON.
pub fn extract_manifest_from_wasm(wasm_bytes: &[u8]) -> Option<ConnectorManifest> {
    let mut manifest: Option<ConnectorManifest> = None;
    let mut config_schema_bytes: Option<Vec<u8>> = None;

    for payload in Parser::new(0).parse_all(wasm_bytes) {
        if let Ok(Payload::CustomSection(reader)) = payload {
            match reader.name() {
                MANIFEST_SECTION_NAME => {
                    manifest = serde_json::from_slice(reader.data()).ok();
                }
                CONFIG_SCHEMA_SECTION_NAME => {
                    config_schema_bytes = Some(reader.data().to_vec());
                }
                _ => {}
            }
        }
    }

    if let (Some(ref mut m), Some(bytes)) = (&mut manifest, config_schema_bytes) {
        if let Ok(schema) = serde_json::from_slice(&bytes) {
            m.config_schema = Some(schema);
        }
    }

    manifest
}

/// Parse a connector reference into (connector_id, connector_version).
///
/// Examples:
/// - "rapidbyte/source-postgres@v0.1.0" -> ("source-postgres", "0.1.0")
/// - "source-postgres@v0.1.0"           -> ("source-postgres", "0.1.0")
/// - "source-postgres"                  -> ("source-postgres", "unknown")
pub fn parse_connector_ref(connector_ref: &str) -> (String, String) {
    let after_slash = connector_ref
        .split('/')
        .next_back()
        .unwrap_or(connector_ref);

    let (name, version) = match after_slash.split_once('@') {
        Some((n, v)) => (n.to_string(), v.strip_prefix('v').unwrap_or(v).to_string()),
        None => (after_slash.to_string(), "unknown".to_string()),
    };

    (name, version)
}

/// Resolve a connector reference (e.g. "rapidbyte/source-postgres@v0.1.0")
/// to a .wasm file path on disk.
///
/// Resolution order:
/// 1. RAPIDBYTE_CONNECTOR_DIR env var
/// 2. ~/.rapidbyte/plugins/
///
/// The connector ref is mapped to a filename by extracting the connector name
/// and replacing hyphens with underscores: "source-postgres" -> "source_postgres.wasm"
pub fn resolve_connector_path(connector_ref: &str) -> Result<PathBuf> {
    let name = connector_ref
        .split('/')
        .next_back()
        .unwrap_or(connector_ref)
        .split('@')
        .next()
        .unwrap_or(connector_ref);

    let filename = format!("{}.wasm", name.replace('-', "_"));

    // Check RAPIDBYTE_CONNECTOR_DIR first
    if let Ok(dir) = std::env::var("RAPIDBYTE_CONNECTOR_DIR") {
        let path = Path::new(&dir).join(&filename);
        if path.exists() {
            return Ok(path);
        }
    }

    // Fall back to ~/.rapidbyte/plugins/
    if let Ok(home) = std::env::var("HOME") {
        let path = PathBuf::from(home)
            .join(".rapidbyte")
            .join("plugins")
            .join(&filename);
        if path.exists() {
            return Ok(path);
        }
    }

    anyhow::bail!(
        "Connector '{}' not found. Searched for '{}' in RAPIDBYTE_CONNECTOR_DIR and ~/.rapidbyte/plugins/",
        connector_ref,
        filename
    )
}

/// Load a connector manifest from the embedded custom section in a .wasm binary.
pub fn load_connector_manifest(wasm_path: &Path) -> Result<Option<ConnectorManifest>> {
    let wasm_bytes = std::fs::read(wasm_path)
        .with_context(|| format!("Failed to read wasm binary: {}", wasm_path.display()))?;
    Ok(extract_manifest_from_wasm(&wasm_bytes))
}

#[cfg(test)]
mod tests {
    use super::*;
    use rapidbyte_types::manifest::{Permissions, ResourceLimits, Roles, SourceCapabilities};
    use rapidbyte_types::wire::{ConnectorRole, ProtocolVersion, SyncMode};

    #[test]
    fn test_parse_connector_ref_with_namespace_version() {
        let (id, ver) = parse_connector_ref("rapidbyte/source-postgres@v0.1.0");
        assert_eq!(id, "source-postgres");
        assert_eq!(ver, "0.1.0");
    }

    #[test]
    fn test_parse_connector_ref_without_version() {
        let (id, ver) = parse_connector_ref("source-postgres");
        assert_eq!(id, "source-postgres");
        assert_eq!(ver, "unknown");
    }

    #[test]
    fn test_extract_manifest_from_wasm_bytes() {
        use std::borrow::Cow;
        use wasm_encoder::{CustomSection, Module};

        let manifest = ConnectorManifest {
            id: "test/example".to_string(),
            name: "Example".to_string(),
            version: "0.1.0".to_string(),
            description: "".to_string(),
            author: None,
            license: None,
            protocol_version: ProtocolVersion::V2,
            permissions: Permissions::default(),
            limits: ResourceLimits::default(),
            roles: Roles {
                source: Some(SourceCapabilities {
                    supported_sync_modes: vec![SyncMode::FullRefresh],
                    features: vec![],
                }),
                ..Default::default()
            },
            config_schema: None,
        };
        let json = serde_json::to_vec(&manifest).unwrap();

        let mut module = Module::new();
        module.section(&CustomSection {
            name: Cow::Borrowed("rapidbyte_manifest_v1"),
            data: Cow::Borrowed(&json),
        });
        let wasm_bytes = module.finish();

        let extracted = extract_manifest_from_wasm(&wasm_bytes);
        assert!(extracted.is_some());
        let m = extracted.unwrap();
        assert_eq!(m.id, "test/example");
        assert!(m.supports_role(ConnectorRole::Source));
    }

    #[test]
    fn test_extract_manifest_missing_section() {
        use wasm_encoder::Module;
        let wasm_bytes = Module::new().finish();
        assert!(extract_manifest_from_wasm(&wasm_bytes).is_none());
    }

    #[test]
    fn test_config_schema_from_separate_section() {
        use std::borrow::Cow;
        use wasm_encoder::{CustomSection, Module};

        let manifest = ConnectorManifest {
            id: "test/with-schema".to_string(),
            name: "Test".to_string(),
            version: "1.0.0".to_string(),
            description: "".to_string(),
            author: None,
            license: None,
            protocol_version: ProtocolVersion::V2,
            permissions: Permissions::default(),
            limits: ResourceLimits::default(),
            roles: Roles {
                source: Some(SourceCapabilities {
                    supported_sync_modes: vec![SyncMode::FullRefresh],
                    features: vec![],
                }),
                ..Default::default()
            },
            config_schema: None,
        };
        let manifest_json = serde_json::to_vec(&manifest).unwrap();
        let schema_json =
            br#"{"type":"object","required":["host"],"properties":{"host":{"type":"string"}}}"#;

        let mut module = Module::new();
        module.section(&CustomSection {
            name: Cow::Borrowed("rapidbyte_manifest_v1"),
            data: Cow::Borrowed(&manifest_json),
        });
        module.section(&CustomSection {
            name: Cow::Borrowed("rapidbyte_config_schema_v1"),
            data: Cow::Borrowed(schema_json),
        });

        let result = extract_manifest_from_wasm(&module.finish());
        assert!(result.is_some());
        let m = result.unwrap();
        assert!(m.config_schema.is_some());
        assert_eq!(m.config_schema.unwrap()["type"], "object");
    }

    #[test]
    fn test_separate_section_takes_precedence() {
        use std::borrow::Cow;
        use wasm_encoder::{CustomSection, Module};

        let manifest = ConnectorManifest {
            id: "test/both".to_string(),
            name: "Test".to_string(),
            version: "1.0.0".to_string(),
            description: "".to_string(),
            author: None,
            license: None,
            protocol_version: ProtocolVersion::V2,
            permissions: Permissions::default(),
            limits: ResourceLimits::default(),
            roles: Roles::default(),
            config_schema: Some(serde_json::json!({"required": ["from_manifest"]})),
        };
        let manifest_json = serde_json::to_vec(&manifest).unwrap();
        let section_schema = br#"{"required":["from_section"]}"#;

        let mut module = Module::new();
        module.section(&CustomSection {
            name: Cow::Borrowed("rapidbyte_manifest_v1"),
            data: Cow::Borrowed(&manifest_json),
        });
        module.section(&CustomSection {
            name: Cow::Borrowed("rapidbyte_config_schema_v1"),
            data: Cow::Borrowed(section_schema),
        });

        let m = extract_manifest_from_wasm(&module.finish()).unwrap();
        let schema = m.config_schema.unwrap();
        // Separate section wins over inline
        assert!(schema["required"]
            .as_array()
            .unwrap()
            .contains(&serde_json::json!("from_section")));
    }

    #[test]
    fn test_load_manifest_from_wasm_file() {
        use std::borrow::Cow;
        use wasm_encoder::{CustomSection, Module};

        let manifest = ConnectorManifest {
            id: "embedded/test".to_string(),
            name: "Embedded".to_string(),
            version: "1.0.0".to_string(),
            description: "".to_string(),
            author: None,
            license: None,
            protocol_version: ProtocolVersion::V2,
            permissions: Permissions::default(),
            limits: ResourceLimits::default(),
            roles: Roles::default(),
            config_schema: None,
        };
        let json = serde_json::to_vec(&manifest).unwrap();

        let mut module = Module::new();
        module.section(&CustomSection {
            name: Cow::Borrowed("rapidbyte_manifest_v1"),
            data: Cow::Borrowed(&json),
        });

        let tmp = std::env::temp_dir().join("test_embedded_manifest.wasm");
        std::fs::write(&tmp, module.finish()).unwrap();

        let loaded = load_connector_manifest(&tmp).unwrap();
        assert!(loaded.is_some());
        assert_eq!(loaded.unwrap().id, "embedded/test");

        std::fs::remove_file(&tmp).ok();
    }
}
